module Main exposing (main)

import Array exposing (Array)
import Browser
import GameThings
import Dict exposing (Dict)
import Event exposing (Deal, Event, Quest)
import Html as H exposing (Html)
import Html.Attributes as A
import Html.Events as E
import Platform.Cmd as Cmd
import Process
import Rand
import Random
import Resource exposing (Resource)
import Task
import Time


main : Program Int Model Msg
main =
    Browser.element
        { init = init
        , update = update
        , view = view
        , subscriptions = subscriptions
        }


type alias Model =
    { seed : Random.Seed
    , manualScore : Int
    , tradingScore : Int
    , autoScore : Int
    , triggers : List Event.ResourceTrigger
    , counts : Dict String Int
    , clickValues : Dict String Int
    , deals : Dict Int Deal
    , generateDeals : Bool
    , autoclicks : List (Resource, Float)
    , maxDeals : Int
    , quest1 : Maybe Quest
    , quest2 : Maybe Quest
    , quest3 : Maybe Quest
    }


type Msg
    = Noop
    | ResourceClicked Resource
    | ResourceAutoGenerated Resource
    | DealTaken Int Deal
    | QuestFulfilled Event.QuestPosition Quest
    | RandomDealDelayReceived Float
    | NewDealGenerated { deal : Deal, position : Int }


init : Int -> ( Model, Cmd Msg )
init seedInit =
    ( { seed = Random.initialSeed seedInit
      , manualScore = 0
      , tradingScore = 0
      , autoScore = 0
      , counts = Dict.empty
      , clickValues = Dict.empty |> Dict.insert Resource.coin.name 1
      , triggers = [ GameThings.initTrigger ]
      , autoclicks = []
      , deals = Dict.empty
      , maxDeals = 4
      , generateDeals = False
      , quest1 = Nothing
      , quest2 = Nothing
      , quest3 = Nothing
      }
    , Cmd.none
    )

after : Float -> msg -> Cmd msg
after ms msg =
    Process.sleep ms |> Task.perform (always msg)


applyEvents : List Event -> ( Model, Cmd Msg ) -> ( Model, Cmd Msg )
applyEvents events modelcmd =
    let
        handleEvent : Event.Event -> ( Model, Cmd Msg ) -> ( Model, Cmd Msg )
        handleEvent event ( model, cmdmsg ) =
            case event of
                Event.StartGeneratingDeals ->
                    ( model
                    , Cmd.batch [ cmdmsg, genDealAfterDelay ]
                    )


                Event.AddQuest position quest ->
                    ( case position of
                        Event.First ->
                            { model
                                | quest1 = Just quest
                            }
                        Event.Second ->
                            { model
                                | quest2 = Just quest
                            }
                        Event.Third ->
                            { model
                                | quest3 = Just quest
                            }
                    , cmdmsg
                    )

                Event.AddDeal index deal ->
                    ( { model
                        | deals = model.deals |> Dict.insert index deal
                      }
                    , cmdmsg
                    )

                Event.SetClickValueForResource resName newClickVal ->
                    ( { model | clickValues = model.clickValues |> Dict.insert resName newClickVal
                      }
                    , cmdmsg
                    )

                Event.AddResourceTrigger trigger ->
                    ( { model | triggers = trigger::model.triggers }
                    , cmdmsg
                    )

                Event.SetAutoGeneration res msBetweenClick ->
                    ( { model | autoclicks = (res, msBetweenClick) :: model.autoclicks }
                    , cmdmsg
                    )
                
                Event.AddDealCapacity capacityToAdd ->
                    ( { model | maxDeals = model.maxDeals + capacityToAdd }
                    , cmdmsg
                    )
    in
    List.foldl handleEvent modelcmd events


checkResourceTriggers : ( Model, Cmd Msg ) -> ( Model, Cmd Msg )
checkResourceTriggers ( model, cmdmsg ) =
    let
        ( eventsFromTriggers, unsatisfiedTriggers ) =
            model.triggers
                |> Event.partitionTriggers model.counts

        ( newModel, newCmd ) =
            applyEvents eventsFromTriggers ( model, cmdmsg )
    in
    ( { newModel | triggers = unsatisfiedTriggers }
    , Cmd.batch [ cmdmsg, newCmd ]
    )


genDealAfterDelay : Cmd Msg
genDealAfterDelay =
    Random.float 1000 7000
        |> Random.generate RandomDealDelayReceived


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        Noop ->
            ( model, Cmd.none )

        ResourceClicked res ->
            let
                currentCount =
                    model.counts
                        |> Dict.get res.name
                        |> Maybe.withDefault 0

                clickValue =
                    model.clickValues
                        |> Dict.get res.name
                        |> Maybe.withDefault 0

                totalValueGenerated = clickValue * res.value
            in
            ( { model
                | counts = model.counts |> Dict.insert res.name (currentCount + clickValue)
                , manualScore = model.manualScore + totalValueGenerated
              }
            , Cmd.none
            )
                |> checkResourceTriggers
        
        ResourceAutoGenerated res ->
            let
                currentCount =
                    model.counts
                        |> Dict.get res.name
                        |> Maybe.withDefault 0
            in
            ( { model | counts = model.counts |> Dict.insert res.name (currentCount + 1)
                    , autoScore = model.autoScore + res.value }
            , Cmd.none
            )

        DealTaken index deal ->
            let
                ( sellResource, sellResourceCount ) =
                    deal.sell

                ( buyResource, buyResourceCount ) =
                    deal.buy

                sellResourceCountInInventory =
                    model.counts
                        |> Dict.get sellResource.name
                        |> Maybe.withDefault 0
            in
            -- need to make the trade in the deal
            ( { model
                | counts =
                    let
                        buyResourceCountInInventory =
                            model.counts
                                |> Dict.get buyResource.name
                                |> Maybe.withDefault 0
                    in
                    model.counts
                        |> Dict.insert sellResource.name (sellResourceCountInInventory - sellResourceCount)
                        |> Dict.insert buyResource.name (buyResourceCountInInventory + buyResourceCount)
                , tradingScore = model.tradingScore + Event.dealValue deal
                , deals = model.deals |> Dict.remove index
              }
            , Cmd.none
            )
                |> checkResourceTriggers
                |> applyEvents deal.events

        QuestFulfilled position quest ->
            let
                newCounts =
                    quest.cost
                        |> List.foldl
                            (\( res, resCount ) counts ->
                                let
                                    resCountInInventory =
                                        counts |> Dict.get res.name |> Maybe.withDefault 0
                                in
                                counts
                                    |> Dict.insert res.name (resCountInInventory - resCount)
                            )
                            model.counts
            in
            ( case position of
                Event.First ->
                    { model
                        | counts = newCounts
                        , quest1 = Nothing
                    }
                Event.Second ->
                    { model
                        | counts = newCounts
                        , quest2 = Nothing
                    }
                Event.Third ->
                    { model
                        | counts = newCounts
                        , quest3 = Nothing
                        }
            , Cmd.none
            )
                |> applyEvents quest.events

        NewDealGenerated { deal, position } ->
            ( { model
                | deals = model.deals |> Dict.insert position deal
              }
            , genDealAfterDelay
            )

        RandomDealDelayReceived timeUntilNextDealGenerated ->
            let
                generate =
                    Random.map2 (\deal position -> { deal = deal, position = position })
                        (Rand.genDeal { counts = model.counts })
                        (Random.int 0 (model.maxDeals - 1))

                ( newDealInfo, seed0 ) =
                    Random.step generate model.seed
            in
            ( { model | seed = seed0 }
            , after timeUntilNextDealGenerated (NewDealGenerated newDealInfo)
            )


subscriptions : Model -> Sub Msg
subscriptions model =
    model.autoclicks
        |> List.map 
            (\(res, msBetweenClicks) ->
                Time.every msBetweenClicks (\posix -> ResourceAutoGenerated res)
            )
        |> Sub.batch


margin0 : H.Attribute msg
margin0 =
    A.style "margin" "0"


view : Model -> Html Msg
view model =
    let
        viewEmptyQuestItem = 
            H.div 
                [ A.style "visibility" "hidden"
                ] 
                [ viewQuest Dict.empty Event.First { title = "", description = "", cost = [], events = [] }
                ]
        viewQuestMaybe : Dict String Int -> Event.QuestPosition -> Maybe Quest -> Html Msg
        viewQuestMaybe counts position maybeQuest =
            case maybeQuest of
                Just quest -> viewQuest counts position quest
                Nothing -> viewEmptyQuestItem
    in
    H.div
        [ A.style "display" "grid"
        , A.style "grid-template-columns" "1fr 1fr"
        ]
        [ H.div
            [ A.style "display" "flex"
            , A.style "flex-direction" "column"
            , A.style "align-items" "center"
            ]
            [ viewDeals model
            , viewResources model
            , viewScoreBar model
            ]
        , viewQuestMaybe model.counts Event.First model.quest1
        , viewQuestMaybe model.counts Event.Second model.quest2
        , viewQuestMaybe model.counts Event.Third model.quest3
        ]


viewDeals : { r | counts : Dict String Int, deals : Dict Int Deal } -> Html Msg
viewDeals { counts, deals } =
    let
        greatestIndex : Int
        greatestIndex =
            deals
                |> Dict.toList
                |> List.map Tuple.first
                |> List.maximum
                |> Maybe.withDefault 0

        htmlDeals : List (Html Msg)
        htmlDeals =
            List.range 0 greatestIndex
                |> List.map
                    (\index ->
                        case Dict.get index deals of
                            Just deal ->
                                viewDeal index deal

                            Nothing ->
                                viewEmptyDeal
                    )

        viewEmptyDeal =
            H.div [ A.style "visibility" "hidden" ]
                [ viewDeal 0 { sell = ( Resource.coin, 10 ), buy = ( Resource.coin, 10 ), events = [] }
                ]

        viewDeal index deal =
            let
                ( sellResource, sellResourceCount ) =
                    deal.sell

                ( buyResource, buyResourceCount ) =
                    deal.buy

                sellResourceCountInInventory =
                    counts
                        |> Dict.get sellResource.name
                        |> Maybe.withDefault 0

                canCompleteDeal =
                    sellResourceCountInInventory >= sellResourceCount

                backgroundColor =
                    if canCompleteDeal then
                        "#88ff88"

                    else
                        "#ff8888"
            in
            H.button
                [ A.style "background" backgroundColor
                , A.style "border" "1px solid black"
                , A.style "padding" "1rem 1rem"
                , E.onClick
                    (if canCompleteDeal then
                        DealTaken index deal

                     else
                        Noop
                    )
                ]
                [ H.span
                    [ A.style "display" "flex"
                    , A.style "align-items" "center"
                    , A.style "font-weight" "bold"
                    , A.style "font-size" "1.1rem"
                    , A.style "padding" ".5rem"
                    , A.style "background-image" "url(tradecraft/arrowred.png)"
                    , A.style "background-size" "50% 100%"
                    , A.style "background-repeat" "no-repeat"
                    , A.style "background-position" "right top"
                    ]
                    [ H.text <| String.fromInt sellResourceCount ++ "x"
                    , H.img
                        [ A.src sellResource.image
                        , A.width 24
                        , A.height 24
                        ]
                        []
                    ]
                , H.span
                    [ A.style "display" "flex"
                    , A.style "align-items" "center"
                    , A.style "justify-content" "center"
                    , A.style "font-weight" "bold"
                    , A.style "font-size" "1.1rem"
                    , A.style "padding" ".5rem"
                    , A.style "background-image" "url(tradecraft/arrowgreen.png)"
                    , A.style "background-size" "50% 100%"
                    , A.style "background-position" "left top"
                    , A.style "background-repeat" "no-repeat"
                    ]
                    [ H.img
                        [ A.src buyResource.image
                        , A.width 24
                        , A.height 24
                        ]
                        []
                    , H.text <| "x" ++ String.fromInt buyResourceCount
                    ]
                ]
    in
    H.div
        [ margin0
        , A.style "width" "100%"
        , A.style "gap" "5px"
        , A.style "display" "grid"
        , A.style "grid-template-columns" "1fr 1fr 1fr 1fr"
        ]
        htmlDeals


viewScoreBar : { r | manualScore : Int, tradingScore : Int, autoScore : Int } -> Html msg
viewScoreBar { manualScore, tradingScore, autoScore } =
    H.div [ margin0, A.style "width" "100%" ]
        [ H.p
            [ margin0
            , A.style "border" "1px solid black"
            , A.style "text-align" "center"
            , A.style "font-weight" "bold"
            ]
            [ H.text <| "Score: " ++ String.fromInt (manualScore + tradingScore + autoScore) ]
        , H.p
            [ margin0
            , A.style "font-size" ".65rem"
            , A.style "bordper" "1px solid black"
            , A.style "padding" "4px"
            , A.style "text-align" "center"
            ]
            [ H.text <| "Manual score: " ++ String.fromInt manualScore ++ " ; Trading score: " ++ String.fromInt tradingScore ++ " ; Auto score: " ++ String.fromInt autoScore ]
        ]

arrayLastWhere : (a -> Bool) -> Array a -> Maybe (Int, a)
arrayLastWhere fn array =
    arrayLastWhereHelp fn array (Array.length array - 1) (Array.length array)

arrayLastWhereHelp : (a -> Bool) -> Array a -> Int -> Int -> Maybe (Int, a)
arrayLastWhereHelp fn array i n =
    if i < 0 then
        Nothing
    else
        case Array.get i array of
            Just a ->
                if fn a then
                    Just (i, a)
                else
                    arrayLastWhereHelp fn array (i - 1) n
            Nothing ->
                arrayLastWhereHelp fn array (i - 1) n


viewResources : { r | counts : Dict String Int, clickValues : Dict String Int } -> Html Msg
viewResources { counts, clickValues } =
    let
        bestResourceUnlockedIndex : Int
        bestResourceUnlockedIndex =
            Resource.resourceArray
                |> arrayLastWhere
                    (\res ->
                        counts
                            |> Dict.get res.name
                            |> Maybe.withDefault 0
                            |> \count -> count > 0
                    )
                |> Maybe.map Tuple.first
                |> Maybe.withDefault 0

        bestResourceUnlockedIndexPlusOne : Int
        bestResourceUnlockedIndexPlusOne =
            min (bestResourceUnlockedIndex + 1) (Resource.numResources - 1)

        htmlResources : List (Html Msg)
        htmlResources =
            if bestResourceUnlockedIndexPlusOne == 1 then
                -- exception: if only coin is unlocked, don't show wood!
                [ viewResource (counts |> Dict.get Resource.coin.name |> Maybe.withDefault 0) True (ResourceClicked Resource.coin) Resource.coin
                ]
            else
            List.range 0 bestResourceUnlockedIndexPlusOne
                |> List.map
                    (\index ->
                        let
                            res =
                                Resource.resourceArray
                                    |> Array.get index
                                    |> Maybe.withDefault Resource.coin  -- shouldnt fall through bc of how the indices are calculated above

                            count =
                                counts |> Dict.get res.name |> Maybe.withDefault 0

                            useColouredBackground =
                                clickValues
                                    |> Dict.get res.name
                                    |> Maybe.withDefault 0
                                    |> \clickValue -> clickValue > 0
                        in
                        viewResource count useColouredBackground (ResourceClicked res) res
                    )


        numResources =
            List.length htmlResources

        numColumns =
            min numResources 4

        gridTemplateColumns =
            List.repeat numColumns "1fr"
                |> String.join " "
    in
    H.div
        [ A.style "display" "grid"
        , A.style "grid-template-columns" gridTemplateColumns
        , A.style "width" "100%"
        , A.style "gap" "5px"
        ]
        htmlResources


viewResource : Int -> Bool -> Msg -> Resource -> Html Msg
viewResource count colouredBackground clickMsg resource =
    H.button
        [ A.style "display" "flex"
        , A.style "flex-direction" "column"
        , A.style "align-items" "center"
        , A.style "border" "1px solid black"
        , A.style "padding" "8px"
        , A.style "background"
            (if colouredBackground then
                resource.backgroundColor

             else
                "white"
            )
        , E.onClick clickMsg
        ]
        [ H.p [ margin0 ]
            [ H.text <| "Value: " ++ String.fromInt resource.value ]
        , H.img [ A.src resource.image, A.height 30, A.width 30 ] []
        , H.p [ margin0, A.style "font-weight" "bold" ]
            [ H.text (String.fromInt count) ]
        , H.p [ margin0 ]
            [ H.text resource.name ]
        ]


viewQuest : Dict String Int -> Event.QuestPosition -> Quest -> Html Msg
viewQuest counts position quest =
    let
        canCompleteQuest =
            quest.cost
                |> List.all
                    (\( res, resCountNeeded ) ->
                        let
                            countInInventory =
                                counts |> Dict.get res.name |> Maybe.withDefault 0
                        in
                        countInInventory >= resCountNeeded
                    )

        backgroundColor =
            if canCompleteQuest then
                "#88FF88"

            else
                "#FF8888"
    in
    H.button
        [ A.style "background" "white"
        , A.style "border" "none"
        , A.style "background" backgroundColor
        , A.style "padding" "16px"
        , E.onClick
            (if canCompleteQuest then
                QuestFulfilled position quest

            else
                Noop
            )
        ]
        [ H.h3
            [ A.style "margin" "0 0 8px 0"
            ]
            [ H.text quest.title
            ]
        , H.div
            [ A.style "display" "flex"
            , A.style "flex-direction" "row"
            , A.style "gap" "8px"
            ]
            [ H.div []
                (quest.cost
                    |> List.map
                        (\( res, resCount ) ->
                            H.div [ A.style "display" "flex", A.style "align-items" "center" ]
                                [ H.text <| String.fromInt resCount
                                , H.span [ A.style "margin" "0 2px" ] [ H.text "x" ]
                                , H.img [ A.src res.image, A.width 30, A.height 30 ] []
                                ]
                        )
                )
            , H.p [ margin0 ]
                [ H.text quest.description
                ]
            ]
        ]
